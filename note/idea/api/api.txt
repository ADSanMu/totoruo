1.根据请求的时间长短来划定该api请求的等级（等级会随着在一定时间内该API请求的时间长短和频率进行升级和降级）

	（保存请求的时间最长和最短记录和15min内的请求次数）
	a.请求的等级决定数据返回策略
		1. job级别（该级别最高），则不需要请求，直接返回存储值
		2. cache
		3. now 直接请求




	b.等级的升降



	c. 等级的判定条件（和b相关）



      			请求时间        长         短

      请求次数

       多                       job        若次数统计超过一定频率，则是job和（1.1）一样/反之cache


       少                     缓存该数据，但是不设置job，当某次请求数据过期时要重新请求   直接请求


       频率升级的限定值(变换可能大，顾是影响请求等级的主要因素)

       请求时长的限定值（变化不大，主要和上游有关）

 A.请求进来，首先检查map中是否存在该请求的api封装对象，不用加锁和double check。
   若没有，则直接请求数据，在数据请求成功后，创建api封装对象并放入cache(不用加锁，就算并发重复放入也不要紧)
   根据请求的消耗时长，设置该API对象的level，如果时长小于阈值，则设置为now，如果请求时间较长则设置为cache级别，同时也在该api对象的
   一个环形数组中存储一个当前时间戳，该环形数组在填满后就重头覆盖。数组固定长度为20.
 B.若cache中存在该请求的api封装对象，使用该API封装对象来获取数据，同时记录此时请求发生的时间戳

 C.设置一个job定时器，每5s(配置设定)检查所有cache中的API封装对象
 	1.检查level是job级别，查看请求时间戳记录数组中的请求频率是否满足job、level，如果不满足，就降级到cache级别
 	2.检查cache级别的请求频率是否满足升级到job level,如果满足就升级到job级别
 	3.检查now级别的请求频率是否满足升级到cache级别(级别的配置设定)


 	注意：
 		1.请求时间超过阈值的api将会被设置为cache级别，没有超过的默认设置为FRESH级别，若是有指定默认最低级别，采用设置，在定时检查中再根据情况来升级，cache级别不会降级。
 		2.在请求ApiExecutor中设置api的cache策略，默认是不对api中带参数的请求进行API封装（可以通过参数配置实现）
 		3.在实现中要提供3次(默认)重试，并提供2个hook函数，一个是检查返回结果是否是合法的函数，返回值是boolean，一个是非法或者请求异常调用的函数(供调用者重试的机会)
 		4.当升级到job level后，提供调用者设置job调度的频率，即多久调用一次，若没有设置，就按照请求时长和请求的频率(数组中时间戳)来设定。
 		5.环形数组的实现，因为可以覆盖数据，所以只需要维护一个index指向下一个位置，该应用可能被多线程同时修改，可以填充缓存行来提高缓存命中率。
 		6.在使用API封装对象时，要注意多线程，虽然没有脏数据的问题。
 		7.设置请求cache策略类 IMMEDIATE(不做任何处理直接，同样不会升降级)/DYNAMIC(就是上述的逻辑，包含了降级和升级.默认级别)/STATIC(该请求只有一份，同样不会升降级)
 		8.API封装类中的数组在钝化后要全部清空
 		9.API封装类要需要记录该api对象产生依赖请求时间最长和最短的记录，在检查job执行时要考虑api请求的次数和平均时长的综合情况，
 		  也就是平均时长更长的需要升级的次数更少，平均时长更短的需要次数更多。
 		10.当请求策略为DYNAMIC时，以iopv为例，请求直接发出，且此时存在多个页面，当检测job发现iopv的请求符合升级到job的条件，
 		   检测是否设定了job的调度周期，iopv设置的周期为15s,所以把job设置为15/s，把API封装对象的level设置为job，当设置完成后
 		   有请求来，就直接返回当前值。若在一定时间内都没有请求iopv，那么在检查job发现已经不符合job的情况，iopv应该降级到cache级别。
 		   若请求中没有设置cache应该存在多久，就根据请求的频率和请求的时长考虑，若设置了就直接设置该cache的有效期。在有效期内，请求来
 		   时，将直接返回数据，如果cache过期了，这直接请求一次，当请求的次数多了，在检查job进行检查时，发现iopv的请求又多了起来符合升级的条件，
 		   又开始为其升级到job级别。
 		11.API的level只有在第一次创建和定时检查job才有机会设定
 		12.运行设置API的最低等级，比如IOPV的最低等级是cache，也就是说,当第一次触发IOPV的API请求是，发现请求时长没有达到cache级别，但是如果
 		   有指定最低等级级别为cache，则直接进入cache的层级。


 		级别：
 		    SCHEDULE 若设置schedule为默认级别需要配置调度参数。
 		    VOLATILE 若设置volatile为默认级别，需要设置过期参数
 		    FRESH 默认级别，不需要任何参数。

 		升级条件：
 		    1.当某次请求第一次请求较长，设置为cache。
 		    2.当检查job发现某个请求频率很高(包括VOLATILE和FRESH)，升级为job

 		降级条件：只有job级别会降级，所以在检查时有一次机会，也就是当一次检查发现不符合job级别条件，不会立刻降级，标志为待降级，若下次还是不符合，降级，
 		         若下次符合，去掉待降级标志。



 		悲观/乐观策略
 		    悲观：在升级时，认为此次高频率的请求是偶然的，会把API设置为待升级，在下一次检查中若还符合条件，再升级，若不符合升级，撤销待升级状态
 		         在降级时，认为已经不符合条件，且接下来也不会有太多的请求，立刻降级
 		    乐观:在升级时，认为此次高频率的请求出现，接下来还会有类似的情况，立刻升级
 		         在降级时，认为还是有可能会有高频率请求，设置为待降级状态，在下一次还不符合时再降级，若还是符合，撤销待降级状态。















































