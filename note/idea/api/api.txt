1.根据请求的时间长短来划定该api请求的等级（等级会随着在一定时间内该API请求的时间长短和频率进行升级和降级）

	（保存请求的时间最长和最短记录和15min内的请求次数）
	a.请求的等级决定数据返回策略
		1. job级别（该级别最高），则不需要请求，直接返回存储值
		2. cache
		3. now 直接请求




	b.等级的升降



	c. 等级的判定条件（和b相关）



      			请求时间        长         短

      请求次数

       多                       job        若次数统计超过一定频率，则是job和（1.1）一样/反之直接请求


       少                     缓存该数据，但是不设置job，当某次请求数据过期时要重新请求   直接请求


       频率升级的限定值(变换可能大，顾是影响请求等级的主要因素)

       请求时长的限定值（变化不大，主要和上游有关）

 A.请求进来，首先检查map中是否存在该请求的api封装对象，不用加锁和doublecheck。
   若没有，则直接请求数据，在数据请求成功后，创建api封装对象并放入cache(不用加锁，就算并发重复放入也不要紧)
   根据请求的消耗时长，设置该API对象的level，如果时长小于阈值，则设置为now，否则设置为cache，同时也在该api对象的
   一个环形数组中存储一个当前时间戳，该环形数组在填满后就重头覆盖。数组固定长度为20.
 B.若cache中存在该请求的api封装对象，使用该API封装对象来获取数据，同时记录此时请求发生的时间戳

 C.设置一个job定时器，每15s检查所有cache中的API封装对象
 	1.检查level是job级别，查看请求时间戳记录数组中的请求频率是否满足job、level，如果不满足，就降级到cache级别
 	2.检查cache级别的请求频率是否满足升级到job level,如果满足就升级到job级别
 	3.检查now级别的请求频率是否满足升级到cache级别



 	注意：
 		1.请求时间超过阈值的api将会被设置为cache级别，在定时检查中再根据情况来升级，cache级别不会降级。
 		2.在请求ApiExcutor中设置api的cache策略，默认是不对api中带参数的请求进行API封装（可以通过参数配置实现）
 		3.在实现中要提供3次(默认)重试，并提供2个hook函数，一个是检查返回结果是否是合法的函数，返回值是boolean，一个是非法或者请求异常调用的函数(供调用者重试的机会)
 		4.当升级到job level后，提供调用者设置job调度的频率，即多久调用一次，若没有设置，就按照请求时长和请求的频率(数组中时间戳)来设定。









































